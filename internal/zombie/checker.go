package zombie

import (
	"context"
	"fmt"
	"runtime"
	"sync"

	"golang.org/x/sync/errgroup"
	"golang.org/x/sync/semaphore"

	"github.com/sanposhiho/gomockhandler/internal/util"
)

type Checker struct {
	isMockManaged map[string]bool
	mux           sync.RWMutex
}

func NewChecker() *Checker {
	return &Checker{
		isMockManaged: map[string]bool{},
	}
}

const (
	CommentGeneratedByGoMock = "// Code generated by MockGen. DO NOT EDIT."
)

func (c *Checker) Check() []string {
	var zombieList []string
	for key, value := range c.isMockManaged {
		if !value {
			zombieList = append(zombieList, key)
		}
	}

	return zombieList
}
func (c *Checker) Search(key string) bool {
	c.mux.RLock()
	_, ok := c.isMockManaged[key]
	c.mux.RUnlock()
	if ok {
		c.mux.Lock()
		c.isMockManaged[key] = true
		c.mux.Unlock()
	}

	return ok
}

func (c *Checker) FindMocks(ctx context.Context) error {
	trees, err := util.Tree(".")
	if err != nil {
		return fmt.Errorf("failed to create dir tree: %w", err)
	}

	if err := c.setHash(ctx, trees); err != nil {
		return fmt.Errorf("failed to set map of checker: %w", err)
	}

	return nil
}

func (c *Checker) setHash(ctx context.Context, trees []string) error {
	eg, _ := errgroup.WithContext(ctx)
	sem := semaphore.NewWeighted(int64(runtime.GOMAXPROCS(0)))

	for _, path := range trees {
		path := path
		sem.Acquire(ctx, 1)

		eg.Go(func() error {
			defer sem.Release(1)
			line, err := util.ReadALine(path)
			if err != nil {
				return fmt.Errorf("failed to readline to find a mock: %w", err)
			}
			if line == CommentGeneratedByGoMock {
				c.mux.Lock()
				key := path
				c.isMockManaged[key] = false
				c.mux.Unlock()
			}
			return nil
		})
	}

	if err := eg.Wait(); err != nil {
		return fmt.Errorf("it happened with errorgroup in setMap: %w", err)
	}

	return nil
}
